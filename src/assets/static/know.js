
const know = [{
        hash: "e50c91428363efa7f078c53cc47bea5303fcae53",
        fileName: "783ce45fa081ce7e5c0f71f3e2eafe972568065b",
        title: "富文本编辑器内核 - slate",
        filePath: "/blogs/know/",
        date: "Sat Jan 01 2022 10:25:59 GMT+0800 (中国标准时间)",
        description: "## slate简介@@@  **当前版本号0.66.5**@@@@@@  >  slate is a completely customizable framework for building rich text editors.@@@  @@@  slate 是一个用于构建富文本编辑器的完全可定制的框架。@@@@@@  个人理解，slate可用来作为一个富文本编辑器内核，在此基础上，可以完全自主的开发自己的富文本编辑器@@@",
        outline: ["## slate简介","## 安装","## 常用核心概念","## 一些常用操作","### 指定编辑器获取焦点","### 编辑器全部选中","### 设置编辑器选区","### 给编辑器选区添加指定的标记","### 给编辑器选区删除指定的标记","### 获取指定属性的Node","### 把选区合并","### 替换文案","## slate架构","### model（模型）","### selection（选区）","### Transforms（变换）","### 插件机制","### slate-react","## 更多"],
      },{
        hash: "97787d951c5925ca88c2410c65dbe27e500540f6",
        fileName: "ecd8beedef623f5b19f0586e357e47a6c979ffc9",
        title: "不可变数据合集 - immutable",
        filePath: "/blogs/know/",
        date: "Mon Dec 27 2021 22:39:28 GMT+0800 (中国标准时间)",
        description: "## 简介@@@@@@Immutable collections for JavaScript@@@@@@> JavaScript 的不可变集合@@@",
        outline: ["## 简介","## 安装","## 代码示例","### Map","### List","### merge和concat","### toJS","### fromJS","### 判断相等性","### 深度嵌套","### Lazy Seq","## 更多"],
      },{
        hash: "ee3be55e36a0a07b4b6b3117b4bfa9099f1a2862",
        fileName: "218910252930db0d76af7079eb6064e99079c904",
        title: "抓包和代理神器 - whistle",
        filePath: "/blogs/know/",
        date: "Sun Dec 26 2021 17:46:33 GMT+0800 (中国标准时间)",
        description: "## 简介@@@whistle(读音 [ˈwɪsəl]，拼音 [wēisǒu] )是基于 Node 实现的跨平台抓包调试代理工具，有以下基本功能：@@@  * 查看 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求响应数据@@@  * 修改 HTTP、HTTPS、HTTP2、WebSocket、TCP 请求响应数据@@@  * 修改请求 url、方法、头部、内容等@@@  * 修改响应状态码、头部、内容，并支持本地替换等@@@  * 修改 WebSocket 和 TCP 收发的帧数据@@@  * 设置 hosts（支持 IPv6）、http-proxy、https-proxy、socks@@@  * 作为HTTP代理或反向代理@@@  * 集成常用的 web 调试工具，如 weinre 和 log 等@@@  * 支持用 Node 编写插件扩展@@@@@@## 安装@@@@@@  yarn: `yarn add whistle` @@@",
        outline: ["## 简介","## 安装","## 基本操作与配套设置","## 本地服务配置代理","## 配置规则","## 过滤条件设置","## 更多","## 关于chrome的跨域"],
      },{
        hash: "255db67e2ef88f5a4e451d3b3161e6e10f0fe81e",
        fileName: "7e18a9b345fbda87051d9f878d7ad556813e735e",
        title: "现代应用管理手段-Docker",
        filePath: "/blogs/know/",
        date: "Sun Dec 26 2021 17:46:33 GMT+0800 (中国标准时间)",
        description: "@@@Docker是一种管理应用的现代手段，让应用管理变得可以预测和高效。@@@@@@简单讲，Docker不隔离计算， 只隔离环境。@@@",
        outline: ["## 什么是环境？什么是计算？","##  Docker是一种隔离技术而非虚拟化","## docker镜像与容器的关系","## 常用命令行","## 修改docker镜像的源","## docker - mysql","## 更多 "],
      },{
        hash: "32992d08ce27a96e10a4d29d9998a65076ecfd20",
        fileName: "0ccafe9b9cd7f2ed8c276454a58d66a72adf8f20",
        title: "diff比较对象一致性 - microdiff",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## microdiff 简介@@@@@@Microdiff 是一个小型（目前<1kb）、快速、零依赖对象和数组比较库。它比大多数其他深度比较库要快得多，并且具有完整的 TypeScript 支持。@@@@@@## 使用@@@```js@@@  import diff from \"microdiff\";@@@",
        outline: ["## microdiff 简介","## 使用","## type","## 对数组的支持","## 为啥要用microdiff","## 更多"],
      },{
        hash: "911b558624af5eca5b2d9be8dde47f92959e654b",
        fileName: "86b8f03d81d0c27da931c64e4bda9c750b3fabd3",
        title: "node进程守护-pm2",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## 简介@@@@@@  pm2 node的生产环境管理器（管理开发环境也行啊），用来守护node启动的服务@@@  pm2 有两种模式 fork（创建一个进程） 和 class（集群模式，IO的多路复用）@@@@@@## 安装@@@  * npm install pm2@@@  * yarn add pm2@@@",
        outline: ["## 简介","## 安装","## 基础命令","## pm2 + nginx","## pm2.io：监控和诊断 Web 界面","## 更多"],
      },{
        hash: "9db467b45747b76943038ab89ed9ec31e8476454",
        fileName: "8547bf4505a24b112e4f90140b65c4b43b6bdfa4",
        title: "函数式编程工具库 - ramdaJS",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## Ramda @@@@@@  > 一款实用的 JavaScript 函数式编程库 - 也是目前最理想的js函数式编程工具库。@@@@@@  > 与其他函数式的库相比，Ramda 的目标更为专注：专门为函数式编程风格而设计，更容易创建函数式 pipeline、且从不改变用户已有数据。@@@",
        outline: ["## Ramda ","## 安装","## 示例","## 部分API","## 应用场景","## 一些函数式编程中重要的概念","## 其他函数式工具库","## 更多"],
      },{
        hash: "8469f11dab13e35eb69b1b00ad4e9480506e71c1",
        fileName: "30acd349153ca5895325b119fac89f752cb59c7b",
        title: "前端mock数据 - mockjs",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## mockjs简介@@@@@@  Mock.js is a simulation data generator to help the front-end to develop and prototype separate from the back-end progress and reduce some monotony particularly while writing automated tests.@@@@@@  > Mock.js 是一个模拟数据生成器，帮助前端开发和原型与后端进程分离，减少一些单调，特别是在编写自动化测试时。@@@",
        outline: ["## mockjs简介","## 安装","## 示例","## 语法规范","### 数据模板","### 数据占位符","## 实用API","### Mock.mock( rurl?, rtype?, template|function(options) )","### Mock.Random","## 更多"],
      },{
        hash: "69f1b6e3237fce981947f14c4a7c331effa07686",
        fileName: "01102a9f94542b8ee92f341eb2a110f2f05f6015",
        title: "前端性能分析 - web-vitals",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## web-vitals简介@@@@@@web-vitals 是google chrome团队开发，用来协助开发者优化网站性能得工具，它会按照chrome的评判标准，直观的返回一些性能指标@@@@@@> react的脚手架cra中，默认安装了这个库@@@",
        outline: ["## web-vitals简介","## 安装","### 使用cdn引入","## 基本用法","### 示例 ","### 性能指标对象","## polyfill使用方法","## 注意事项","## 一次发送多个报告","## 配套设施","## 兼容性","## 限制","## 更多"],
      },{
        hash: "1315dcee534d5552aa2a396f62d3d0a57ef44287",
        fileName: "1696cc762fd1efa41316217f4b733a3c29e020fe",
        title: "爬虫-puppeteer",
        filePath: "/blogs/know/",
        date: "Tue Dec 14 2021 12:41:50 GMT+0800 (中国标准时间)",
        description: "## 简介@@@  Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。Puppeteer 默认以 headless 模式运行，但是可以通过修改配置文件运行\"有头\"模式。 @@@  通常用来做为爬虫使用，但是只要与chrome有关的工作都可以使用，比如自动化测试，扩展测试等。@@@@@@## 示例@@@```js@@@  const puppeteer = require('puppeteer');@@@@@@  (async () => {@@@    const browser = await puppeteer.launch();@@@    const page = await browser.newPage();@@@    await page.goto('https://example.com');@@@    await page.screenshot({path: 'example.png'});@@@",
        outline: ["## 简介","## 示例","### 开启“有头”模式","### 复制操作","### 屏幕截图","### 元素操作","## 更多"],
      }]

export default know
