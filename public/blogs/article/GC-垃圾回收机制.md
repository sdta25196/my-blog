## 垃圾回收

  c一类的语言拥有底层的内存管理原语`malloc()`和`free()`，
  而像javascript这样的高级语言，会自动释放内存，这一过程就是**内存垃圾回收**
  
  > 虽然我们有自动的垃圾回收机制，依然会有内存管理的问题，例如内存泄露等

## 内存生命周期

  * **分配内存**－内存由操作系统分配给程序使用。在底层语言中开发者可以显式地操作内存。而在高级语言中就是垃圾回收机制。
  * **使用内存**－这是程序实际使用之前分配的内存的阶段。当你在代码中使用已分配的变量的时候，就会发生内存读写的操作。
  * **释放内存**－该阶段你可以释放你不再使用的整块内存，该内存就可以被释放且可用。和内存分配操作一样，底层语言可显式进行该操作。
  
## JavaScript 中的分配内存

  JavaScript 自己处理内存分配而不需要开发者干涉，与此同时声明变量值。
  ```js
    var n = 374; // 为数字分配内存
    var s = 'sessionstack'; // 为字符串分配内存

    var o = {
      a: 1,
      b: null
    }; // 为对象及其值分配内存

    var a = [1, null, 'str']; // (类似对象)为数组及其数组元素值分配内存

    function f(a) {
      return a + 3;
    } // 分配一个函数(一个可调用对象)

    // 函数表达式也分配一个对象
    someElement.addEventListener('click', function() {
      someElement.style.backgroundColor = 'blue';
    }, false);
  ```

  一些函数调用也会生成对象分配：
  ```js
    var d = new Date(); // 分配一个日期对象

    var e = document.createElement('div'); // 分配一个 DOM 元素
  ```

  可以分配值或对象的方法：
  ```js
    var s1 = 'sessionstack';
    var s2 = s1.substr(0, 3); // s2 为一个新字符串
    // 因为字符串是不可变的，所以 JavaScript 可能会选择不分配内存而只是存储数组 [0, 3] 的内存地址范围。
    var a1 = ['str1', 'str2'];
    var a2 = ['str3', 'str4'];
    var a3 = a1.concat(a2);
    // 包含 4 个元素的新数组由 a1 和 a2 数组元素所组成
  ```
## JavaScript 中的使用内存
  
  我们使用变量，为函数传参等行为就是在使用内存

## JavaScript 中的释放内存

  javascript中集成了垃圾回收器，垃圾回收器会追踪内存的分配和使用情况，在它认为内存需要释放的时候，便会自动释放内存片段

  而内存是否闲置是具有不可判断性的，所以这个阶段就容易出现内存管理的问题，目前垃圾回收器有两种回收机制

  ### 方法一：垃圾回收引用计数

  这是最简单的内存垃圾回收算法。当一个对象被 0 引用，会被标记为 "可回收内存垃圾"。

  ```js
    var o1 = {
      o2: {
        x: 1
      }
    };

    // 创建两个对象。
    // 'o1' 引用对象 'o2' 作为其属性。全部都是不可回收的。

    // 'o3' 是第二个引用 'o1' 对象的变量
    var o3 = o1;

    o1 = 1; // 现在，原先在 'o1' 中的对象只有一个单一的引用，以变量 'o3' 来表示

    // 引用对象的 'o2' 属性。
    // 该对象有两个引用：一个是作为属性，另一个是 'o4' 变量
    var o4 = o3.o2;

    // 'o1' 对象现在只有 0 引用，它可以被作为内存垃圾回收。
    // 然而，其 'o2' 属性仍然被变量 'o4' 所引用，所以它的内存不能够被释放。
    o3 = '374';

    o4 = null;
    // 'o1' 中的 'o2' 属性现在只有 0 引用了。所以 'o1' 对象可以被回收。

  ```

  **循环引用带来的bug**

  循环引用会造成一个限制。在以下的示例中，创建了两个互相引用的对象，这样就会造成循环引用。函数调用之后他们将会超出范围，所以，实际上它们是无用且可以释放对他们的引用。然而，引用计数算法会认为由于两个对象都至少互相引用一次，所以他们都不可垃圾回收。
  ```js
    function f() {
      var o1 = {};
      var o2 = {};
      o1.P = O2; // O1 引用 o2
      o2.p = o1; // o2 引用 o1. 这就造成循环引用
    }

    f();
  ```

  ### 方法二：标记-清除算法
  
  > 2012年起，所有的现代浏览器都内置了一个标记－清除垃圾回收器

  为了判断是否需要释放对对象的引用，算法会确定该对象是否可获得。

  标记-清除算法包含三个步骤：

  * 根：一般来说，根是代码中引用的全局变量。在JavaScript中，window 对象即是可看作根的全局变量。Node.js中相对应的变量为 "global"。垃圾回收器会构建出一份所有根变量的完整列表。

  * 随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。

  * 最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。

  **如何解决的循环引用**
    根据标记-清除算法，即使两个内存循环引用的时候，也无法从根变量获取到他们，所以，循环引用的变量也会被回收

## 万物都有其两面性

  **内存垃圾回收器具有不确定性**，意思即内存垃圾回收具有不可预见性。
  
  * 我们不能确定内存垃圾回收的确切时机。这意味着在某些情况下，程序会使用比实际需要更多的内存。
  * 在其它情况下，在特定的交互敏感的程序中，短暂的停顿会引人注意。
  * 虽然不确定性意味着不能够确定什么时候可以进行内存垃圾收集，但是大多数 GC 的实现都共享一种模式，即在内存分配期间进行垃圾回收。
    
如果没有进行内存分配，大多数的内存垃圾回收器就会保持闲置状态。
  * 分配一段相当大的内存。
  * 大多数的元素(或所有)被标记为不可获得(假设我们赋值我们不再需要的缓存为 null )
  * 不再分配其它内存。

在以上几种情况下，大多数的内存垃圾回收器不会再运行任何的内存垃圾回收。也就是说：即使可以对不可获得的引用进行垃圾回收，垃圾收集器也不会进行标记。虽然这不是严格意义上的内存泄漏，但是这会导致高于平常的内存使用率。

## 四种常见的javascript内存泄露

  1. 意外的全局变量 - 可以通过在 JavaScript 文件的顶部添加 'use strict' 来避免这个问题
  ```js
    // 意外的注册的全局变量bar
    function foo(arg) {
      bar = "some text";
    }
  ```

  2. 定时器及被遗忘的回调函数 - 所以千万要记得销毁定时器
  3. 闭包 - 这个存疑。目前的现代浏览器应该不会造成内存泄露，可参考司徒正美或者阮一峰的相关解读
  4. 移除 DOM 引用
  ```js
    var elements = {
      button: document.getElementById('button'),
      image: document.getElementById('image')
    };

    function doStuff() {
      elements.image.src = 'http://example.com/image_name.png';
    }

    function removeImage() {
        // image 元素是 body 元素的直系后代元素
        document.body.removeChild(document.getElementById('image'));
        // 这时，我们仍然在 elements 全局对象中引用了 #button 元素
        // 换句话说，按钮元素仍然在内存中且不能够被垃圾回收器收集
    }
  ```
## 管理内存的方式
  > 尽可能减少内存占用，尽可能减少 GC。我们不知道GC什么时间执行，但是我们不希望GC频繁执行
  
  **减少 GC 次数**
  
  浏览器会不定时回收垃圾内存，称为 GC，不定时触发，**一般在向浏览器申请新内存时，浏览器会检测是否到达一个临界值再进行触发**。一般来说，GC 会较为耗时，GC 触发时可能会导致页面卡顿及丢帧。故我们要尽可能避免GC的触发。GC 无法通过代码触发，但部分浏览器如 Chrome，可在 DevTools -> TimeLine 页面手动点击 CollectGarbage 按钮触发 GC。

  **减少内存占用**

  降低内存占用，可避免内存占用过多导致的应用/系统卡顿，App 闪退等，在移动端尤为明显。当内存消耗较多时，浏览器可能会频繁触发 GC。而如前所述，GC 发生在申请新内存时，若能避免申请新内存，则可避免GC 触发。