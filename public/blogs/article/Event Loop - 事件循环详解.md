## 事件循环
  
事件循环就是 JavaScript在 **引擎等待任务**、**执行任务**、**进入休眠状态等待更多任务**这几个状态之间转换的无限循环。

JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行

例如：

  * 当外部脚本 `<script src="...">` 加载完成时，任务就是执行它。
  * 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。
  * 当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。
  * 等等...

出现任务 —— 引擎处理它们 —— 等待更多任务（即休眠，几乎不消耗 CPU 资源）。

如果一个任务到来时，引擎正处于繁忙状态，比如正在处理的上一个任务比较耗时，那么新来的任务就会被排入队列。

多个任务组成了一个队列，即所谓的**宏任务队列(macrotask queue)**

每一个宏任务在执行过程中有可会产生微任务，所有产生的微任务会添加到**微任务队列(microtask queue)**
  
  > 有点蒙哈？简单说：`<script></script>`标签包裹的代码中有一个promise，且这个promise被解决(resolve)了,他就会被添加到当前的微任务队列，待宏任务执行完成就会被执行，代码示例如下
  
  ```js
   <script>
      // 这是第1个宏任务
      let num = 1;
      new Promise((resolve,reject)=>{
          resolve(1)
      }).then(e=>{
          num+=e
      })
      // 此时num === 1,因为这是当前宏任务的最后一行代码，执行完这一行才会去执行 .then中的num+=e
      console.log(num) //1 
   </script>
   <script>
      // 这是第2个宏任务
      // 此时num === 2，以为第一个宏任务执行完成之后 执行了微任务队列，所以第二个宏任务执行的时候 num+=e 已经被执行了
      console.log(num) //2 
   </script>
  ```

当前执行的宏任务一旦执行完成，就会立刻执行**宏任务执行过程中产生的**微任务队列，简单理解就是：宏任务队列中每执行一个宏任务，就会把这个宏任务所产生的微任务队列全部执行，然后才会执行宏任务队列中的下一个宏任务

了解了宏任务与微任务队列的执行情况，就需要再知道渲染（render）是什么时候发生的：当每一队微任务队列被清空后（如果有微任务队列的话，没有就是宏任务执行完成后），引擎会查看是否需要进行render,如果需要，就会先执行render操作。


## 浏览器中的宏任务
  * script脚本
  * 定时器
  * Dom操作
  * UI交互事件
  * I\O
  * postMessage

## 浏览器中的微任务
 * promise
 * queueMicrotask
 * Mutation Observer API 

## 总结 & 补充

  * **GUI渲染线程与JS线程是互斥的**，javascript引擎执行任务的时候,渲染引擎不能同时执行，

  * 执行顺序
    1. 宏任务队列中队首的宏任务
    2. 对首宏任务执行中产生的微任务队列
    3. 引擎检查是否需要render，检查是否有事件回调函数（例如click事件回调）
    4. 出队当前宏任务，执行宏任务队列中的下一个宏任务
    5. 如果没有下一个宏任务了，就进入休眠状态，等待程序产生宏任务再次执行第1步
   
  * 点击事件算宏任务还是微任务？
    * 点击事件是一个异步的任务，拥有一个不确定执行时间的回调函数，它不属于宏任务或者微任务，它会在上述执行顺序中的第3步，微任务队列执行完成引擎检查任务时执行。
  
  * 常用的添加宏任务方式
    * 使用零延迟的setTimeout

  * 常用的添加微任务方式
    * promise
    * queueMicrotask
